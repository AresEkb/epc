modeltype EPC uses 'http://www.example.org/epc';
modeltype PT uses 'http:///ptnet.ecore';

transformation EpcToPetriNet(in epc : EPC, out pt : PT);

main()
{
    epc.rootObjects()[Model]->toPetriNet();
}

mapping EPC::Model::toPetriNet() : PT::PetriNetDoc
{
    nets := object PT::PetriNet {
        type := PNType::PTNET;
        id := 'model'.uniqueId();
        name := self.toName();
        pages := object PT::Page {
            id := 'page'.uniqueId();
            name := self.toName();
            objects := self.elements->toObject();
            // All nodes are mapped already, so we can use non-late resolve in the following mappings
            self.elements->toObjects()->forEach (objs) {
                objects += objs;
            };
            // Inclusive or-gate synchronization nodes
            self.elements[EPC::Gate]->toOrSync()->forEach (objs) {
                objects += objs;
            };
        };
        'p'.startStrCounter('p');
    };
}

mapping EPC::ModelElement::toObject() : PT::PnObject
disjuncts
    EPC::ModelElement::toNode,
    EPC::ControlFlow::toArc
{
}

mapping EPC::ModelElement::toNode() : PT::Node
disjuncts
    EPC::Event::toPlace,
    EPC::Function::toTransition
{
}

mapping EPC::Event::toPlace() : PT::Place
{
    id := 'p'.uniqueId();
    name := self.toName();
}

mapping EPC::Function::toTransition() : PT::Transition
{
    id := 't'.uniqueId();
    name := self.toName();
}

mapping EPC::ControlFlow::toArc() : PT::Arc
{
    id := 'a'.uniqueId();
    source := self.source.late resolveoneIn(EPC::ModelElement::toNode);
    target := self.target.late resolveoneIn(EPC::ModelElement::toNode);
}

mapping EPC::ModelElement::toObjects() : List(PT::PnObject)
disjuncts
    EPC::Gate::toAnd,
    EPC::Gate::toXor,
    EPC::Gate::toOr
{
}

mapping EPC::Gate::toAnd() : List(PT::PnObject)
when { self.kind = EPC::GateKind::andGate }
{
    var mainNode : PT::Transition;

    var inputIsFunction := self.inputs->size() = 1 and self.inputs->forAll(oclIsKindOf(EPC::Function));
    var outputIsFunction := self.outputs->size() = 1 and self.outputs->forAll(oclIsKindOf(EPC::Function));

    // Main node
    if (inputIsFunction) {
        mainNode := self.inputs->at(1).resolveoneIn(EPC::ModelElement::toNode).oclAsType(PT::Transition);
    }
    elif (outputIsFunction) {
        mainNode := self.outputs->at(1).resolveoneIn(EPC::ModelElement::toNode).oclAsType(PT::Transition);
    }
    else {
        mainNode := object PT::Transition {
            id := 't'.uniqueId();
            name := object PT::Name { text := 'And' };
        };
        result += mainNode;
    };

    // Input nodes
    if (not inputIsFunction) {
        self.inputs->forEach (element) {
            var sourceNode := element.resolveoneIn(EPC::ModelElement::toNode);
            var place : PT::Place;
            if (sourceNode.oclIsKindOf(PT::Place)) {
                place := sourceNode.oclAsType(PT::Place);
            }
            else {
                place := object PT::Place {
                    id := 'p'.uniqueId();
                };
                result += place;
                result += object PT::Arc {
                    id := 'a'.uniqueId();
                    source := sourceNode;
                    target := place;
                };
            };
            result += object PT::Arc {
                id := 'a'.uniqueId();
                source := place;
                target := mainNode;
            };
        };
    };

    // Output nodes
    if (inputIsFunction or not outputIsFunction) {
        self.outputs->forEach (element) {
            var targetNode := element.resolveoneIn(EPC::ModelElement::toNode);
            var place : PT::Place;
            if (targetNode.oclIsKindOf(PT::Place)) {
                place := targetNode.oclAsType(PT::Place);
            }
            else {
                place := object PT::Place {
                    id := 'p'.uniqueId();
                };
                result += place;
                result += object PT::Arc {
                    id := 'a'.uniqueId();
                    source := place;
                    target := targetNode;
                };
            };
            result += object PT::Arc {
                id := 'a'.uniqueId();
                source := mainNode;
                target := place;
            };
        };
    };
}

mapping EPC::Gate::toXor() : List(PT::PnObject)
when { self.kind = EPC::GateKind::xorGate }
{
    var mainNode : PT::Place;

    var inputIsEvent := self.inputs->size() = 1 and self.inputs->forAll(oclIsKindOf(EPC::Event));
    var outputIsEvent := self.outputs->size() = 1 and self.outputs->forAll(oclIsKindOf(EPC::Event));

    // Main node
    if (inputIsEvent) {
        mainNode := self.inputs->at(1).resolveoneIn(EPC::ModelElement::toNode).oclAsType(PT::Place);
    }
    elif (outputIsEvent) {
        mainNode := self.outputs->at(1).resolveoneIn(EPC::ModelElement::toNode).oclAsType(PT::Place);
    }
    else {
        mainNode := object PT::Place {
            id := 'p'.uniqueId();
            name := object PT::Name { text := 'Xor' };
        };
        result += mainNode;
    };

    // Input nodes
    if (not inputIsEvent) {
        self.inputs->forEach (element) {
            var sourceNode := element.resolveoneIn(EPC::ModelElement::toNode);
            var transition : PT::Transition;
            if (sourceNode.oclIsKindOf(PT::Transition)) {
                transition := sourceNode.oclAsType(PT::Transition);
            }
            else {
                transition := object PT::Transition {
                    id := 't'.uniqueId();
                };
                result += transition;
                result += object PT::Arc {
                    id := 'a'.uniqueId();
                    source := sourceNode;
                    target := transition;
                };
            };
            result += object PT::Arc {
                id := 'a'.uniqueId();
                source := transition;
                target := mainNode;
            };
        };
    };

    // Output nodes
    if (inputIsEvent or not outputIsEvent) {
        self.outputs->forEach (element) {
            var targetNode := element.resolveoneIn(EPC::ModelElement::toNode);
            var transition : PT::Transition;
            if (targetNode.oclIsKindOf(PT::Transition)) {
                transition := targetNode.oclAsType(PT::Transition);
            }
            else {
                transition := object PT::Transition {
                    id := 't'.uniqueId();
                };
                result += transition;
                result += object PT::Arc {
                    id := 'a'.uniqueId();
                    source := transition;
                    target := targetNode;
                };
            };
            result += object PT::Arc {
                id := 'a'.uniqueId();
                source := mainNode;
                target := transition;
            };
        };
    };
}

mapping EPC::Gate::toOr() : List(PT::PnObject)
when { self.kind = EPC::GateKind::orGate }
{
    var mainNode : PT::Place;

    var inputIsEvent := self.inputs->size() = 1 and self.inputs->forAll(oclIsKindOf(EPC::Event));
    var outputIsEvent := self.outputs->size() = 1 and self.outputs->forAll(oclIsKindOf(EPC::Event));

    // Main node
    if (inputIsEvent) {
        mainNode := self.inputs->at(1).resolveoneIn(EPC::ModelElement::toNode).oclAsType(PT::Place);
    }
    elif (outputIsEvent) {
        mainNode := self.outputs->at(1).resolveoneIn(EPC::ModelElement::toNode).oclAsType(PT::Place);
    }
    else {
        mainNode := object PT::Place {
            id := 'p'.uniqueId();
            name := object PT::Name { text := 'Or' };
        };
        result += mainNode;
    };

    // Input nodes
    if (not inputIsEvent) {
        if (self.inputs->size() = 1) {
            var sourceNode := self.inputs->at(1).resolveoneIn(EPC::ModelElement::toNode);
            result += object PT::Arc {
                id := 'a'.uniqueId();
                source := sourceNode;
                target := mainNode;
            };
        }
        else {
            var n := self.inputs->size();
            var m := 2.pow(n) - 1;
            var transitions := Sequence{1..m}->collect(i | self.xmap toOrJoinTransition(i));
            result += transitions;
            transitions->forEach (transition) {
                result += object PT::Arc {
                    id := 'a'.uniqueId();
                    source := transition;
                    target := mainNode;
                };
            };

            var k := 1;
            self.inputs->forEach (element) {
                var sourceNode := element.resolveoneIn(EPC::ModelElement::toNode);
                var place : PT::Place;
                if (sourceNode.oclIsKindOf(PT::Place)) {
                    place := sourceNode.oclAsType(PT::Place);
                }
                else {
                    place := object PT::Place {
                        id := 'p'.uniqueId();
                    };
                    result += place;
                    result += object PT::Arc {
                        id := 'a'.uniqueId();
                        source := sourceNode;
                        target := place;
                    };
                };
                var i := 1;
                transitions->forEach (transition) {
                    if (i.div(k).mod(2) = 1) {
                        result += object PT::Arc {
                            id := 'a'.uniqueId();
                            source := place;
                            target := transition;
                        };
                    };
                    i := i + 1;
                };
                k := k * 2;
            };
        };
    };

    // Output nodes
    if (inputIsEvent or not outputIsEvent) {
        if (self.outputs->size() = 1) {
            var targetNode := self.outputs->at(1).resolveoneIn(EPC::ModelElement::toNode);
            var transition : PT::Transition;
            if (targetNode.oclIsKindOf(PT::Transition)) {
                transition := targetNode.oclAsType(PT::Transition);
            }
            else {
                transition := object PT::Transition {
                    id := 't'.uniqueId();
                };
                result += transition;
                result += object PT::Arc {
                    id := 'a'.uniqueId();
                    source := transition;
                    target := targetNode;
                };
            };
            result += object PT::Arc {
                id := 'a'.uniqueId();
                source := mainNode;
                target := transition;
            };
        }
        else {
            var n := self.outputs->size();
            var m := 2.pow(n) - 1;
            var transitions := Sequence{1..m}->collect(i | self.xmap toOrSplitTransition(i));
            result += transitions;
            transitions->forEach (transition) {
                result += object PT::Arc {
                    id := 'a'.uniqueId();
                    source := mainNode;
                    target := transition;
                };
            };

            var k := 1;
            self.outputs->forEach (element) {
                var targetNode := element.resolveoneIn(EPC::ModelElement::toNode);
                var place : PT::Place;
                if (targetNode.oclIsKindOf(PT::Place)) {
                    place := targetNode.oclAsType(PT::Place);
                }
                else {
                    place := object PT::Place {
                        id := 'p'.uniqueId();
                    };
                    result += place;
                    result += object PT::Arc {
                        id := 'a'.uniqueId();
                        source := place;
                        target := targetNode;
                    };
                };
                var i := 1;
                transitions->forEach (transition) {
                    if (i.div(k).mod(2) = 1) {
                        result += object PT::Arc {
                            id := 'a'.uniqueId();
                            source := transition;
                            target := place;
                        };
                    };
                    i := i + 1;
                };
                k := k * 2;
            };
        };
    };
}

mapping EPC::Gate::toOrSplitTransition(i : Integer) : PT::Transition
{
    id := 't'.uniqueId();
}

mapping EPC::Gate::toOrJoinTransition(i : Integer) : PT::Transition
{
    id := 't'.uniqueId();
}

// TODO: The simplest variant is implemented
// Or-split should be followed by or-join
// Another gates between or-gates are not allowed
// Look at the following link for the problem description:
// https://researcher.watson.ibm.com/researcher/files/zurich-hvo/bpm-2012.pdf
// Or-joins should be implemented differently
// In some scenarios they can't be implemented in a Petri net at all
mapping EPC::Gate::toOrSync() : List(PT::PnObject)
when { self.kind = EPC::GateKind::orGate and self.inputs->size() > 1 }
{
    var sourceOrGates := self.inputs->collect(findSourceOrGate())->asOrderedSet();
    assert fatal (sourceOrGates->size() = 1 and sourceOrGates->at(1) <> null) with log('Source or gate not found');

    var splitTransitions := sourceOrGates->at(1).resolveIn(EPC::Gate::toOrSplitTransition);
    var joinTransitions := self.resolveIn(EPC::Gate::toOrJoinTransition);
    assert fatal (splitTransitions->size() > 0) with log('Split or-transitions not found');
    assert fatal (splitTransitions->size() = joinTransitions->size()) with log('There should be the same number of split and join or-transitions');

    Sequence{1..splitTransitions->size()}->forEach (i) {
        var place := object PT::Place {
            id := 'p'.uniqueId();
        };
        result += place;
        result += object PT::Arc {
            id := 'a'.uniqueId();
            source := splitTransitions->at(i);
            target := place;
        };
        result += object PT::Arc {
            id := 'a'.uniqueId();
            source := place;
            target := joinTransitions->at(i);
        };
    };
}

query EPC::ModelElement::findSourceOrGate() : EPC::Gate =
    let connection = self.model.elements[Connection]->any(target = self) in
    if connection <> null then connection.source.findSourceOrGate()
    else self.model.elements[Gate]->any(kind = EPC::GateKind::orGate and outputs->includes(self)) endif;

query Model::toName() : PT::Name =
    object PT::Name { text := self.name.translit() };

query NamedElement::toName() : PT::Name =
    object PT::Name { text := self.name.translit() };

query Integer::pow(n : Integer) : Integer = Sequence{1..n}->iterate(acc : Integer = 1 | acc * self);

query String::uniqueId() : String = self + self.incrStrCounter(self).toString();

query String::translit() : String =
    self.replaceAll('а', 'a')
        .replaceAll('б', 'b')
        .replaceAll('в', 'v')
        .replaceAll('г', 'g')
        .replaceAll('д', 'd')
        .replaceAll('е', 'e')
        .replaceAll('ё', 'yo')
        .replaceAll('ж', 'zh')
        .replaceAll('з', 'z')
        .replaceAll('и', 'i')
        .replaceAll('й', 'y')
        .replaceAll('к', 'k')
        .replaceAll('л', 'l')
        .replaceAll('м', 'm')
        .replaceAll('н', 'n')
        .replaceAll('о', 'o')
        .replaceAll('п', 'p')
        .replaceAll('р', 'r')
        .replaceAll('с', 's')
        .replaceAll('т', 't')
        .replaceAll('у', 'u')
        .replaceAll('ф', 'f')
        .replaceAll('х', 'h')
        .replaceAll('ц', 'c')
        .replaceAll('ч', 'ch')
        .replaceAll('ш', 'sh')
        .replaceAll('щ', 'sch')
        .replaceAll('ъ', '')
        .replaceAll('ы', 'y')
        .replaceAll('ь', '')
        .replaceAll('э', 'e')
        .replaceAll('ю', 'yu')
        .replaceAll('я', 'ya')
        .replaceAll('А', 'A')
        .replaceAll('Б', 'B')
        .replaceAll('В', 'V')
        .replaceAll('Г', 'G')
        .replaceAll('Д', 'D')
        .replaceAll('Е', 'E')
        .replaceAll('Ё', 'Yo')
        .replaceAll('Ж', 'Zh')
        .replaceAll('З', 'Z')
        .replaceAll('И', 'I')
        .replaceAll('Й', 'Y')
        .replaceAll('К', 'K')
        .replaceAll('Л', 'L')
        .replaceAll('М', 'M')
        .replaceAll('Н', 'N')
        .replaceAll('О', 'O')
        .replaceAll('П', 'P')
        .replaceAll('Р', 'R')
        .replaceAll('С', 'S')
        .replaceAll('Т', 'T')
        .replaceAll('У', 'U')
        .replaceAll('Ф', 'F')
        .replaceAll('Х', 'H')
        .replaceAll('Ц', 'C')
        .replaceAll('Ч', 'Ch')
        .replaceAll('Ш', 'Sh')
        .replaceAll('Щ', 'Sch')
        .replaceAll('Ъ', '')
        .replaceAll('Ы', 'Y')
        .replaceAll('Ь', '')
        .replaceAll('Э', 'E')
        .replaceAll('Ю', 'Yu')
        .replaceAll('Я', 'Ya');
